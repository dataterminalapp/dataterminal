import { Layout } from "@/features/panel";

export const CHECKBOX_ID = "DATATERMINAL_checkbox";

export interface ColumnDefMeta {
  columnName: string;
  isCheckbox?: boolean;
}

export function buildEditorInput(
  layout: Layout,
  input?: string,
  historyInput?: string
) {
  if (layout === "IDE") {
    return input;
  } else {
    if (historyInput) {
      const splittedInput = historyInput.trim().split("\n");
      const firstLine = splittedInput[0];
      if (splittedInput.length > 1) {
        if (firstLine.trim().endsWith(";")) {
          return firstLine;
        } else {
          return firstLine + " ...";
        }
      } else {
        return firstLine;
      }
    } else {
      return input;
    }
  }
}

export interface ParsedQueryResult {
  sql: string;
  startLine: number;
  endLine: number;
}

/**
 * This functions is AI-generated by Claude 3.5 Sonnet
 * @param text
 * @returns
 */
export const splitQueries = (text: string): ParsedQueryResult[] => {
  const sqls: ParsedQueryResult[] = [];
  let currentQuery = "";
  let currentLine = 1;
  let queryStartLine = 1;
  let inString = false;
  let stringChar = "";
  let inComment = false;
  let inMultilineComment = false;
  let escaped = false;

  const finalizeQuery = () => {
    const trimmedQuery = currentQuery.trim();
    if (trimmedQuery !== "") {
      // Only add non-empty queries
      sqls.push({
        sql: trimmedQuery, // Keep the semicolon if it's present
        startLine: queryStartLine,
        endLine: currentLine,
      });
    }
    currentQuery = "";
    queryStartLine = currentLine;
  };

  for (let i = 0; i < text.length; i++) {
    const char = text[i];
    const nextChar = text[i + 1] || "";

    // Handle newlines for line counting
    if (char === "\n") {
      currentLine++;
    }

    // Handle comments
    if (!inString) {
      // Single line comments
      if (char === "-" && nextChar === "-") {
        inComment = true;
      }
      // Multi-line comments
      if (char === "/" && nextChar === "*") {
        inMultilineComment = true;
      }
    }

    // End of single line comment
    if (inComment && char === "\n") {
      inComment = false;
      currentQuery += char;
      continue;
    }

    // End of multi-line comment
    if (inMultilineComment && char === "*" && nextChar === "/") {
      inMultilineComment = false;
      currentQuery += char + nextChar;
      i++; // Skip the next char
      continue;
    }

    // Handle dollar-quoted string literals
    if (char === "$" && !inString && !inComment && !inMultilineComment) {
      const dollarQuoteMatch = text.slice(i).match(/^\$([a-zA-Z0-9_]*)\$/);
      if (dollarQuoteMatch) {
        const fullTag = dollarQuoteMatch[0];
        const endTagIndex = text.indexOf(fullTag, i + fullTag.length);

        if (endTagIndex !== -1) {
          // Include the entire dollar-quoted string
          currentQuery += text.slice(i, endTagIndex + fullTag.length);
          i = endTagIndex + fullTag.length - 1;
          continue;
        }
      }
    }

    // Handle standard string literals
    if (!inComment && !inMultilineComment) {
      if ((char === "'" || char === '"') && !escaped) {
        if (!inString) {
          inString = true;
          stringChar = char;
        } else if (char === stringChar) {
          inString = false;
        }
      }
    }

    // Handle escape characters
    if (char === "\\" && !escaped) {
      escaped = true;
      currentQuery += char;
      continue;
    }

    // Reset escape flag
    if (escaped) {
      escaped = false;
      currentQuery += char;
      continue;
    }

    // Check for semicolon outside of string literals and comments
    if (char === ";" && !inString && !inComment && !inMultilineComment) {
      currentQuery += char; // Add the semicolon to the current query
      finalizeQuery();
    } else {
      currentQuery += char;
    }
  }

  // Add the last query if there is one
  if (currentQuery.trim()) {
    const trimmedQuery = currentQuery.trim();
    sqls.push({
      sql: trimmedQuery, // Keep the semicolon if it's present
      startLine: queryStartLine,
      endLine: currentLine,
    });
  }

  if (sqls.length === 0) {
    return [
      {
        sql: "",
        startLine: 0,
        endLine: 0,
      },
    ];
  }

  return sqls;
};
